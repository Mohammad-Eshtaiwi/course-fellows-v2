//  this is generated by ai
// deal with it as 3rd party library
// no need to understand it
// just use it

"use client";

import { useEffect, useRef, useState } from "react";

// YouTube Player API types
declare global {
  interface Window {
    YT: {
      Player: new (elementId: string, config: YTPlayerConfig) => YTPlayer;
      ready: (callback: () => void) => void;
      PlayerState: {
        ENDED: number;
        PLAYING: number;
        PAUSED: number;
        BUFFERING: number;
        CUED: number;
      };
    };
    onYouTubeIframeAPIReady: () => void;
  }
}

interface YTPlayerConfig {
  height?: string | number;
  width?: string | number;
  videoId: string;
  playerVars?: {
    start?: number;
    autoplay?: 0 | 1;
    controls?: 0 | 1;
    rel?: 0 | 1;
    modestbranding?: 0 | 1;
    showinfo?: 0 | 1;
    iv_load_policy?: 1 | 3;
    disablekb?: 0 | 1;
    fs?: 0 | 1;
    cc_load_policy?: 0 | 1;
  };
  events?: {
    onReady?: (event: { target: YTPlayer }) => void;
    onStateChange?: (event: { target: YTPlayer; data: number }) => void;
    onError?: (event: { target: YTPlayer; data: number }) => void;
  };
}

interface YTPlayer {
  playVideo: () => void;
  pauseVideo: () => void;
  stopVideo: () => void;
  seekTo: (seconds: number, allowSeekAhead?: boolean) => void;
  getCurrentTime: () => number;
  getDuration: () => number;
  getPlayerState: () => number;
  setVolume: (volume: number) => void;
  getVolume: () => number;
  destroy: () => void;
}

interface YouTubePlayerProps {
  url: string;
  start?: number;
  style?: React.CSSProperties;
  onReady?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
  onEnd?: () => void;
  autoplay?: 1 | 0;
}

export default function YouTubePlayer({
  url,
  start = 0,
  style,
  onReady,
  onPlay,
  onPause,
  onEnd,
  autoplay = 1,
}: YouTubePlayerProps) {
  const playerRef = useRef<YTPlayer | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isAPIReady, setIsAPIReady] = useState(false);

  // Extract video ID from YouTube URL
  const extractVideoId = (url: string): string | null => {
    try {
      const urlObj = new URL(url);

      // Handle different YouTube URL formats
      if (urlObj.hostname === "youtu.be") {
        return urlObj.pathname.slice(1);
      }

      if (
        urlObj.hostname === "www.youtube.com" ||
        urlObj.hostname === "youtube.com"
      ) {
        return urlObj.searchParams.get("v");
      }

      return null;
    } catch (error) {
      console.error("Error extracting video ID:", error);
      return null;
    }
  };

  const videoId = extractVideoId(url);

  // Load YouTube API
  useEffect(() => {
    if (window.YT && window.YT.Player) {
      setIsAPIReady(true);
      return;
    }

    // Load YouTube API script if not already loaded
    if (!document.querySelector('script[src*="youtube.com/iframe_api"]')) {
      const script = document.createElement("script");
      script.src = "https://www.youtube.com/iframe_api";
      script.async = true;
      document.head.appendChild(script);
    }

    // Set up callback for when API is ready
    window.onYouTubeIframeAPIReady = () => {
      setIsAPIReady(true);
    };

    return () => {
      // Cleanup
      if (window.onYouTubeIframeAPIReady) {
        window.onYouTubeIframeAPIReady = undefined as any;
      }
    };
  }, []);

  // Initialize player when API is ready
  useEffect(() => {
    if (!isAPIReady || !videoId || !containerRef.current) {
      return;
    }

    // Create unique ID for the player container
    const playerId = `youtube-player-${Date.now()}`;
    containerRef.current.id = playerId;

    // Initialize YouTube player
    playerRef.current = new window.YT.Player(playerId, {
      videoId: videoId,
      playerVars: {
        start: start,
        autoplay,
        controls: 1,
        rel: 0,
        modestbranding: 1,
        showinfo: 0,
        iv_load_policy: 3,
        disablekb: 0,
        fs: 1,
        cc_load_policy: 0,
      },
      events: {
        onReady: (event) => {
          console.log("YouTube player ready");
          onReady?.();
        },
        onStateChange: (event) => {
          const state = event.data;
          if (state === window.YT.PlayerState.PLAYING) {
            onPlay?.();
          } else if (state === window.YT.PlayerState.PAUSED) {
            onPause?.();
          } else if (state === window.YT.PlayerState.ENDED) {
            onEnd?.();
          }
        },
        onError: (event) => {
          console.error("YouTube player error:", event.data);
        },
      },
    });

    // Cleanup function
    return () => {
      if (playerRef.current) {
        try {
          playerRef.current.destroy();
        } catch (error) {
          console.warn("Error destroying YouTube player:", error);
        }
        playerRef.current = null;
      }
    };
  }, [isAPIReady, videoId, start, onReady, onPlay, onPause, onEnd]);

  if (!videoId) {
    return (
      <div style={style}>
        <p>Invalid YouTube URL</p>
      </div>
    );
  }

  return (
    <div
      style={{
        width: "100%",
        height: "auto",
        aspectRatio: "16/9",
        ...style,
      }}
    >
      <div
        ref={containerRef}
        style={{
          width: "100%",
          height: "auto",
          aspectRatio: "16/9",
        }}
      />
    </div>
  );
}
